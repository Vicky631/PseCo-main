# 数据集格式分析报告

## 目标1：数据集格式确认

### 1. COCO格式依赖分析

#### 1.1 当前代码的COCO格式依赖位置

**核心依赖位置：**

1. **阶段4评估模块** (`fsc147/4_1_train_roi_head.py`, 第68行)
   ```python
   from pycocotools.coco import COCO
   coco_gt = COCO(f"{dataset_root}/instances_test_val_bin.json")
   ```
   - **用途**：加载COCO格式的标注文件用于评估
   - **依赖程度**：**强依赖** - 评估指标计算必须使用COCO API

2. **评估指标计算** (`fsc147/4_1_train_roi_head.py`, 第314-322行)
   ```python
   coco_dt = coco_gt.loadRes(coco_preds)
   coco_eval = COCOeval(coco_gt, coco_dt, 'bbox')
   coco_eval.evaluate()
   coco_eval.accumulate()
   coco_eval.summarize()
   ```
   - **用途**：计算检测指标（AP, AP50, AP75等）
   - **依赖程度**：**强依赖** - 必须使用COCO评估API

3. **预测结果格式转换** (`fsc147/4_1_train_roi_head.py`, 第289-300行)
   ```python
   # 转换为COCO评估格式（x1,y1,w,h）
   coco_preds.append({
       "image_id": image_id,
       "category_id": 0,
       "bbox": [float(x1), float(y1), float(w), float(h)],
       "score": float(score)
   })
   ```
   - **用途**：将预测结果转换为COCO格式
   - **依赖程度**：**中等** - 可以修改为其他格式

#### 1.2 非COCO格式的数据加载

**当前数据加载方式：**

1. **阶段1数据预处理** (`fsc147/1_generate_data.py`)
   - 使用自定义JSON格式：`annotation_FSC147_384_with_gt.json`
   - **格式**：`{图像名: {width, height, annotations: {points}, box_examples_coordinates, class_name, split}}`
   - **不依赖COCO格式**

2. **FSC147数据集加载器** (`fsc147/FSC_147.py`)
   - 直接读取JSON文件，不依赖COCO格式
   - **格式要求**：自定义JSON格式

#### 1.3 结论

**COCO格式依赖总结：**

| 模块 | COCO依赖 | 是否可替换 | 替换难度 |
|------|---------|-----------|---------|
| 数据加载（阶段1） | ❌ 无 | ✅ 已支持自定义JSON | 无需修改 |
| 训练流程（阶段2-4） | ❌ 无 | ✅ 已支持自定义格式 | 无需修改 |
| **评估指标计算（阶段4）** | ✅ **强依赖** | ⚠️ 需要适配 | **中等** |

**核心问题：**
- **训练过程不依赖COCO格式**，但**评估阶段强依赖COCO格式**
- 如果新数据集不是COCO格式，需要：
  1. 转换标注为COCO格式（推荐）
  2. 或实现自定义评估器（复杂）

---

### 2. 新数据集适配方案

#### 方案A：转换标注为COCO格式（推荐）

**优点：**
- ✅ 无需修改核心代码
- ✅ 复用现有评估逻辑
- ✅ 支持标准评估指标

**实现步骤：**

1. **创建标注转换工具** (`utils/annotation_converter.py`)
   ```python
   def convert_to_coco_format(custom_annotations, output_path):
       """
       将自定义标注格式转换为COCO格式
       
       输入格式示例（自定义）：
       {
           "image1.jpg": {
               "width": 1024,
               "height": 768,
               "annotations": {
                   "points": [[x1, y1], [x2, y2], ...]
               }
           }
       }
       
       输出：COCO格式JSON文件
       """
   ```

2. **在阶段1预处理时自动转换**
   - 检测标注格式
   - 如果是自定义格式，自动转换为COCO格式
   - 保存转换后的COCO标注文件

#### 方案B：实现自定义评估器（复杂）

**优点：**
- ✅ 完全支持自定义格式
- ❌ 需要重写评估逻辑
- ❌ 可能无法完全兼容COCO指标

**实现步骤：**

1. **创建自定义评估器** (`utils/custom_evaluator.py`)
   ```python
   class CustomEvaluator:
       def __init__(self, annotation_format='custom'):
           self.format = annotation_format
       
       def evaluate(self, predictions, ground_truth):
           """根据标注格式选择评估方法"""
           if self.format == 'coco':
               return self._evaluate_coco(predictions, ground_truth)
           elif self.format == 'custom':
               return self._evaluate_custom(predictions, ground_truth)
   ```

2. **修改阶段4评估函数**
   - 根据配置选择COCO评估器或自定义评估器

---

### 3. 推荐实施方案

**推荐使用方案A（转换标注为COCO格式）**，原因：
1. ✅ 实现简单，只需添加转换工具
2. ✅ 不修改核心训练代码
3. ✅ 保持评估指标一致性
4. ✅ 支持多种输入格式（JSON/TXT/XML）

**实现文件：**
- `utils/annotation_converter.py` - 标注格式转换工具
- `utils/dataset_adapter.py` - 数据集适配器（统一接口）

---

## 4. 适配修改方案（无需重构核心逻辑）

### 4.1 创建标注转换工具

**文件：`utils/annotation_converter.py`**

```python
"""
标注格式转换工具
支持将自定义格式（JSON/TXT/XML）转换为COCO格式
"""
import json
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Tuple

class AnnotationConverter:
    """标注格式转换器"""
    
    @staticmethod
    def convert_json_to_coco(custom_json_path: str, output_path: str, image_dir: str):
        """
        将自定义JSON格式转换为COCO格式
        
        Args:
            custom_json_path: 自定义JSON标注文件路径
            output_path: 输出COCO格式文件路径
            image_dir: 图像目录（用于获取图像信息）
        """
        # 实现转换逻辑
        pass
    
    @staticmethod
    def convert_txt_to_coco(txt_dir: str, output_path: str, image_dir: str):
        """
        将TXT格式标注转换为COCO格式（如YOLO格式）
        """
        pass
    
    @staticmethod
    def convert_xml_to_coco(xml_dir: str, output_path: str, image_dir: str):
        """
        将XML格式标注转换为COCO格式（如Pascal VOC格式）
        """
        pass
```

### 4.2 修改阶段1预处理脚本

在 `stages/stage1_generate_data.py` 中添加：

```python
def check_and_convert_annotations(config):
    """检查标注格式，如不是COCO格式则自动转换"""
    annotation_file = config.get('dataset.annotation_file')
    dataset_type = config.get('dataset.format', 'auto')  # auto, coco, custom
    
    if dataset_type == 'auto':
        # 自动检测格式
        if annotation_file.endswith('.json'):
            # 尝试加载并检测格式
            with open(annotation_file, 'r') as f:
                data = json.load(f)
                if 'images' in data and 'annotations' in data:
                    # COCO格式
                    return annotation_file
                else:
                    # 自定义JSON格式，需要转换
                    dataset_type = 'custom_json'
    
    if dataset_type != 'coco':
        # 转换为COCO格式
        from utils.annotation_converter import AnnotationConverter
        converter = AnnotationConverter()
        coco_output = annotation_file.replace('.json', '_coco.json')
        converter.convert_json_to_coco(annotation_file, coco_output, 
                                      config.get('dataset.image_dir'))
        return coco_output
    
    return annotation_file
```

### 4.3 修改配置文件

在 `config/default_config.yaml` 中添加：

```yaml
dataset:
  name: "fsc147"
  root: "/mnt/mydisk/wjj/dataset/FSC_147"
  annotation_file: "{dataset.root}/annotation_FSC147_384_with_gt.json"
  format: "auto"  # auto, coco, custom_json, custom_txt, custom_xml
  coco_annotation: "{dataset.root}/instances_test_val_bin.json"  # 评估用COCO格式
```

---

## 5. 使用示例

### 5.1 使用自定义JSON格式数据集

```yaml
# config/my_dataset_config.yaml
dataset:
  name: "my_dataset"
  root: "/path/to/my_dataset"
  annotation_file: "{dataset.root}/annotations.json"
  format: "custom_json"  # 指定为自定义格式
  coco_annotation: "{dataset.root}/annotations_coco.json"  # 自动生成
```

运行训练：
```bash
python train_pipeline.py --config config/my_dataset_config.yaml
```

系统会自动：
1. 检测标注格式
2. 转换为COCO格式（用于评估）
3. 使用原始格式进行训练（如果兼容）

---

## 6. 总结

### 核心发现

1. **训练流程不依赖COCO格式** - 使用自定义JSON格式
2. **评估流程强依赖COCO格式** - 必须使用COCO API计算指标
3. **适配方案简单** - 只需添加格式转换工具，无需重构核心逻辑

### 修改建议

1. ✅ 创建 `utils/annotation_converter.py` - 标注格式转换工具
2. ✅ 修改阶段1预处理 - 自动检测和转换格式
3. ✅ 在配置文件中添加 `dataset.format` 字段
4. ✅ 保持核心训练代码不变

### 兼容性

- ✅ **FSC147格式**：完全兼容（当前格式）
- ✅ **自定义JSON格式**：通过转换工具支持
- ✅ **COCO格式**：直接支持
- ⚠️ **TXT/XML格式**：需要实现对应转换器（可选）
